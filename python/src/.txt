create a file in python that receives a graph from networkx and create a population of partitions for a genetic algorithm using adjaceny based, 

create also functions of two-point crossover and random mutation with another adjacent, after that adapt this rust fitness function Q(c) = 1 - intra(c) - inter(c) below to python. 

make the genetic algorithm run and make a visualization in the final of the the best community partitions found, and the original graph.

example output:

```
in the graph:

4 -> 5, 6
5 -> 6,4
6 -> 4,5,8
7 -> 8
8 -> 7

the communities are:

4,5,6

8,7.
```

```
pub fn calculate_objectives(graph: &StableGraph<(), ()>, partition: &Partition) -> (f64, f64, f64) {
    let total_edges = graph.edge_count() as f64;
    if total_edges == 0.0 {
        return (0.0, 0.0, 0.0);
    }
    
    let mut intra_sum = 0.0;
    let mut inter = 0.0;
    let total_edges_doubled = 2.0 * total_edges;  

    // Calculate both metrics for each community
    for community in partition.communities.values() {
        let mut community_edges = 0;
        let mut community_degree = 0.0;

        // Count internal edges and total degree
        for &node in community {
            let node_degree = graph.neighbors(node).count() as f64;
            community_degree += node_degree;
            
            // Count edges within the community
            for neighbor in graph.neighbors(node) {
                if community.contains(&neighbor) {
                    community_edges += 1;
                }
            }
        }

        // Handle edge counting for undirected graphs
        if !graph.is_directed() {
            community_edges /= 2;
        }
        
        intra_sum += community_edges as f64;
        
        // Fix inter-link calculation
        let normalized_degree = community_degree / total_edges_doubled;
        inter += normalized_degree.powi(2);
    }

    let intra = 1.0 - (intra_sum / total_edges);
    let modularity = 1.0 - intra - inter;

    println!("Modularity: {} | Intra: {} | Inter: {}", modularity, intra, inter);

    (modularity.max(-1.0).min(1.0), intra, inter)

}
```